#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/stat.h> /* For mode constants */

#define P(sem_value) sem_wait((sem_value));
#define V(sem_value) sem_post((sem_value));



// pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex3 = PTHREAD_MUTEX_INITIALIZER;
pthread_barrier_t barrier;

sem_t sem;


void* thread_1_non_synchro() {
    sleep(1);
    printf("je ");
    sleep(1);
    printf("mes ");
    return NULL;
}

void* thread_2_non_synchro() {
    sleep(1);
    printf("synchronise ");
    sleep(1);
    printf("threads \n");
    return NULL;
}

void* thread_1_mutex() {

    printf("je ");
    pthread_mutex_unlock(&mutex1);

    pthread_mutex_lock(&mutex2);
    printf("mes ");
    pthread_mutex_unlock(&mutex3);


    return NULL;
}

void* thread_2_mutex() {

    pthread_mutex_lock(&mutex1);
    printf("synchronise ");
    pthread_mutex_unlock(&mutex2);

    pthread_mutex_lock(&mutex3);
    printf("threads \n");
    return NULL;
}

void* thread_1_sem() {

    printf("je ");
    V(&sem);

    P(&sem);
    printf("mes ");
    V(&sem);

    return NULL;
}

void* thread_2_sem() {

    P(&sem);
    printf("synchronise ");
    V(&sem);

    P(&sem);
    printf("threads \n");
    return NULL;
}

void* wait_for_barrier(){

    printf("Thread is waiting... \n");
    sleep(rand() % 3);
    pthread_barrier_wait(&barrier);// Attente de la fin d'éxécution de tous les autres threads
    printf("Every threads have reached the rdv point\nContinuing\n");
    return NULL;
}

void* N_threads_func (void* arg) {
    int id = *(int*)arg;
    printf("Thread %d: Started\n", id);
    sleep(rand() % 3);
    printf("Thread %d: Reached rendezvous\n", id);
    pthread_barrier_wait(&barrier);
    return NULL;
}


int main(void)
{
    int nbChoice;
    pthread_mutex_init(&mutex1, NULL);
    pthread_mutex_init(&mutex1, NULL);
    pthread_mutex_init(&mutex2, NULL);

    while(nbChoice!=6) {

        printf("Quel version voulez vous: \n");
        printf("1) No sync\n");
        printf("2) Sync avec mutex\n");
        printf("3) Sync avec semaphore\n");
        printf("4) Reveilleurs-Reveiller\n");
        printf("5) Producteurs-consommateurs\n");
        printf("6) Quitter\n");
        scanf("%d", &nbChoice);

        switch(nbChoice) {
            case 1: {
                pthread_t thread_1, thread_2;

                pthread_create(&thread_1, NULL, thread_1_non_synchro, NULL);
                pthread_create(&thread_2, NULL, thread_2_non_synchro, NULL);

                pthread_join(thread_1, NULL);
                pthread_join(thread_2, NULL);

                break;
            }
            case 2: {
                pthread_t t1_mutex, t2_mutex;
                pthread_mutex_lock(&mutex1);
                pthread_mutex_lock(&mutex2);
                pthread_mutex_lock(&mutex3);

                pthread_create(&t1_mutex, NULL, thread_1_mutex, NULL);
                pthread_create(&t2_mutex, NULL, thread_2_mutex, NULL);

                pthread_join(t1_mutex, NULL);
                pthread_join(t2_mutex, NULL);

                pthread_mutex_destroy(&mutex1);
                pthread_mutex_destroy(&mutex2);
                pthread_mutex_destroy(&mutex3);
                break;
            }
            case 3: {
                printf("Synchro avec semaphore\n");
                sem_init(&sem, 0, 0);
                pthread_t t1_semaphores, t2_semaphores;
                pthread_create(&t1_semaphores, NULL, thread_1_sem, NULL);
                pthread_create(&t2_semaphores, NULL, thread_2_sem, NULL);

                pthread_join(t1_semaphores, NULL);
                pthread_join(t2_semaphores, NULL);

                sem_destroy(&sem);
                break;
            }
            case 4: {
                printf("Réveilleurs - réveiller \n Veuillez taper un nombre entier représentant le nombre de threads\nNb_threads = ");
                int N;
                scanf("%d",&N);
                system("cls\n");
                printf("Reveilleurs - reveiller avec une barrière de %d threads:\n\n\t",N);
                int ids[N];
                pthread_t N_threads[N];
                pthread_t barrier_thread;
                pthread_barrier_init(&barrier,NULL,N+1);

                pthread_create(&barrier_thread, NULL, wait_for_barrier, NULL);
                for (int i = 0; i < N; i++ ){
                    ids[i] = i + 1;
                    pthread_create(&N_threads[i], NULL, N_threads_func, &ids[i]);
                }

                for (int i = 0; i < N; i++ ){
                    pthread_join(N_threads[i], NULL);
                }
                pthread_join(barrier_thread, NULL);

                printf("\n");
                pthread_barrier_destroy(&barrier);
                break;
            }
            case 5: {
                printf("Réveilleurs - réveiller \n Veuillez taper un nombre entier représentant le nombre de threads\nNb_threads = ");
                int N;
                scanf("%d",&N);
                system("cls\n");
                printf("Réveilleurs - réveiller avec une barrière de %d threads:\n\n\t",N);
                int ids[N];
                pthread_t threads[N];
                pthread_barrier_init(&barrier,NULL,N);

                for (int i = 0; i < N; i++ ){
                    ids[i] = i + 1;
                    // pthread_create(&threads[i], NULL, N_threads_func, &ids[i]);

                }

                for (int i = 0; i < N; i++ ){
                    pthread_join(threads[i], NULL);
                }


                printf("\n");
                pthread_barrier_destroy(&barrier);
                break;
            }
            case 6: {
                printf("Quitter le programme\n");
                break;
            }
            default : {
                printf("Veuillez entrer une valeur comprise entre [1 et 6]\n");
                break;
            }
        }

        sleep(2);
        system("cls\n");
    }
    exit(0);
    return 0;
}